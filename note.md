# 考察メモ

# 5/17

- 短期コンみたいな見た目と入力だけど、結構複雑だな
- クレーンの移動制限が面白い
- 流石にペナルティはない方が良さそうだが、スペースが足りない場合があるのか？
    - 10,000ターンもあればどうとでもなりそう
    - クレーン0が強いので、どんなケースもペナルティは解消できる
- ビームサーチにしろ焼きなましにしろ、強い貪欲が必要
    - 一つのケースを手で解いてみよう
- 運ぶ経路を決める必要がある
    - マルチエージェントな感じはAHC008（動物を囲む回）に似ている
    - 経路の決定はAHC013（サーバールームの回）に似ている
        - 少し場合分けが必要そう
- クレーン0は自由に移動できる
- なんもわからん
    - 自由における場合を考える？
- トポロジカルソート
- いっぺんに解くのは難しそう
    - 自由度高すぎる
- 仮保持しなければおけないコンテナの個数を最小化
- 同時に動かすのは流石に難しい？
- 右から左に持っていくことはあまりしなさそう
- 退避したものを別の場所に移動させることはあるか？
    - 上げるのと下げるのにコストがかかるので、できれば避けたい
    - 横にシフトをする、とかの操作はありうる？
- クレーンの操作はタスク単位で良い？
    - 次のタスクを選ぶ、タスクが終わるまで時間を進める

- 行動単位を「コンテナcをマス(i,j)に運ぶ」とする
- 管理対象
    - コンテナを運ぶ順番
        - 並列で動かすので、順番が前後しそう
    - コンテナを仮に置く位置
    - コンテナを運ぶ経路
- 上記を決めれば、最適なクレーンの割り当てが決まる？
    - 多段階？
    - クレーンの割り当ては多いので、その場で適当にやって良さそう
    - 経路と一緒に最適化することになりそう

## 方針

- コンテナを一時保管する場所を固定する
- 全てのクレーンを使って一つずつ完成させる
    - 運べるものは運んでおく

# 5/18

- クレーン0だけを使えばペナルティはでないので、結局操作回数の最小化
    - 参加の敷居を下げるためだと予想
- コンテナを運ぶ順番を決めるのが良さそう
- 全部を一気にやるのは大変だが、方針は間違えないようにしたい
- クレーンは入り口->仮置き場、仮置き場->出口で役割を分けると無駄が減りそう
    - クレーン0はどっち？
        - 直感的には搬出をやった方が良さそう
- ボトルネックになるのは何か？
    - 運ぶ距離
    - クレーンの待ち時間
        - ガントチャートみたいなものを書く？
- 自由度
    - コンテナを運ぶ順番
    - コンテナを仮位置
- 運び出す順番が後なら、荷物を置く場所は後ろで良い
- 初手がわからん
- 各ジョブを貪欲にやった場合、どれくらい良い解が出るのか
- クレーンが1個の場合
- 仮置き場が自由な場合
- そんなに複雑なことをしたくない
- ターンの最小化 <-> クレーン0以外の待機時間を無くす

## 最適化対象

- 搬入順序
- 仮置き場所
- 搬出順序

- 上記が決まれば、クレーンは貪欲に割り当てれば良さそう
    - クレーンの割り当ては影響少なそう

## 搬入順序

- 仮置き状態のコンテナの個数を減らしたい
- 各時刻tに放置しているコンテナの個数の最小化
- 搬出できるコンテナは全て解消する

## 仮置き場所

- 搬出がしやすい配置を求めたい
- 各時刻の到達不可能なコンテナ配置の最小化

## 搬出順序

- 搬入がしやすくなるように、搬出順序に優先度をつけたい
- 搬出順序は貪欲に決まりそう？
    - 搬出できる状態になったらすぐに搬出した方が良い

## 解表現

- 搬入順序と仮置き場所

# 5/19

- 搬入順序と搬入場所は同時に最適化できそう
- 評価関数
    - 移動距離の総和
        - 搬入口からの距離と搬出口までの距離
    - 到達不可能なコンテナの個数
        - 搬入口から
            - 搬入するたびに到達可能か判定
        - 搬出口から
            - 搬出できるようになった時に到達可能か判定
    - 設置位置の衝突
- 並列なので、順番が前後しても頑健であってほしい
- クレーン0だけを使った解法を提出
    - 順位表を見ると絶対スコアは1/6倍程度にする必要がある
    - 60~70ターンくらいが目標、高々100ターンくらい
    - ビーム撃つことになりそう

## どうやってクレーンを複数動かすか

- ジョブを割り当てる
    - 行動は以下の3種類だが
        - 搬入する
        - 搬出する
        - 搬入と搬出をする
    - 全て、以下の一連の流れ
        - 拾いに行く
        - 拾う
        - 運ぶ
        - 降ろす
    - 最大ターン数が短いので、行動は1ターンずつで良さそう
    - 最適かというと、、
- 考えること
    - 衝突しないようにするには
    - 回避不可能な場合は？

- 最初は貪欲で良い

```rust
struct Task {
    from: (usize, usize),
    to: (usize, usize),
}
```

1. 新たに発生したタスクを列挙する
2. タスクがないクレーンにタスクを割り当てる
3. 各クレーンについて、以下の操作を順に行う
    1. 目的地にいれば、拾う・降ろす操作を行う
    2. いなければ、目的地に近づくような操作のうち、実行可能な操作を列挙する
        - 実行可能 := 次のターンにクレーンが存在しないマス、クレーンと交差しないマス
    3. 2.で列挙した操作からランダムに一つ選択し、実行する
        - 選べない場合はその場に留まる
4. 1.に戻る

- スタック対策
    - 片方が譲る
- 同時に同じ搬出口に運ぶには？
- 時刻t+dに通れなくなっていたら？
- ちゃんと最適化するには、各時刻の状態を記録する必要があるか
    - スタック対策にもなる

```rust
/// terminal[t][i][j] := 時刻tのマス(i, j)の状態
terminal: Vec<Vec<Vec<TileStatus>>>;

fn get_move_for_task(
    terminal: &Vec<Vec<Vec<TileStatus>>>,
    t: usize,
    from: (usize, usize),
    to: (usize, usize),
    task: Task,
) -> Vec<Move> {
    let mut dp = vec![vec![vec![false; N]; N]; T];
}
```

### 考察

- クレーンで持った状態になると、仮置きする必要はなくなる
- 待機が勿体無いので
    - 搬入口は同時に複数利用したい
    - なるべく最後は複数の搬出口に搬出していたい
    - 順序の評価関数を変えればどうにかなるか？
- おそらく方針では差がつかず、各要素の最適化精度で決まる問題な気がする
- 一個前の搬出が完了する時刻が判明したら、次の搬出もキューに入れたい

- 経路やクレーンの衝突を無視して（緩めて）最適化？
- クレーンの経路をどれくらい後から求められるか

```rust
struct Task {
    ij: (usize, usize),
    from: (usize, usize),
    to: (usize, usize),
}
tasks[i] := クレーンiのタスクの順序

// 近傍
move(tasks[i1][j1], tasks[i2][j2])
swap(tasks[i][j1], tasks[i][j2])
swap(tasks[i1][j1], tasks[i2][j2])
// swap(tasks[i1][j1:], tasks[i2][j2:])
// swap(tasks[i1][:j1], tasks[i2][:j2])

// 制約
// s_{i, j} := コンテナa[i,j]が搬入される時刻
// t_{c} := コンテナcが搬出される時刻
//
// s_{i, j1} + 2 <= s_{i, j2} where j1 < j2
// t_{c1} + 2 <= t_{c2} where c1 < c2 and g(c1) == g(c2)
// 中継場所は固定

// 評価関数（移動経路とクレーンの衝突を無視したシミュレーション）
fn simulate(tasks: Vec<Vec<Task>>) -> i64 {
    let mut t = 0;
    let mut t_in = vec![None; N * N];
    let mut t_out = vec![None; N * N];
    let mut cur_task = vec![0; N];
    let mut busy_till = vec![0; N];
    let mut in_task = vec![false; N];

    for ci in 0..N {
        if tasks[ci].len() == 0 {
            continue;
        }
        busy_till[ci] = ci.abs_diff(tasks[ci][0].from.0) + (0_usize).abs_diff(tasks[ci][0].from.1);
    }

    loop {
        for ci in 0..N {
            if cur_task[ci] >= tasks.len() {
                continue;
            }
            if t < busy_till[ci] {
                continue;
            }

            let task = tasks[cur_task[i]];
            if !in_task[ci] {
                // 現在のタスクを開始できるか判定
                let (i, j) = task.ij;

                if j > 0 {
                    let Some(prev_t_in) = t_in[a[i][j - 1]] else {
                        continue;
                    };
                    if t < prev_t_in + 2 {
                        continue;
                    }
                }
                t_in[a[i][j]] = Some(t);
                in_task[ci] = true;
            } else {
                // 現在のタスクを終了できるか判定
                if j > 0 {
                    let Some(prev_t_out) = t_out[a[i][j - 1]] else {
                        continue;
                    };
                    if t < prev_t_out + 2 {
                        continue;
                    }
                }
                t_out[a[i][j]] = Some(t);
                in_task[ci] = false;
                cur_task[ci] += 1;
                if cur_task[ci] < tasks.len() {
                    busy_till[ci] = t + (
                        tasks[ci][cur_task[ci] - 1].to.0.abs_diff(tasks[ci][cur_task[ci]].from.0)
                        + tasks[ci][cur_task[ci] - 1].to.1.abs_diff(tasks[ci][cur_task[ci]].from.1)
                    );
                }
            }
        }
    }
    t
}
```

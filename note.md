# 5/17

- 短期コンみたいな見た目と入力だけど、結構複雑だな
- クレーンの移動制限が面白い
- 流石にペナルティはない方が良さそうだが、スペースが足りない場合があるのか？
    - 10,000ターンもあればどうとでもなりそう
    - クレーン0が強いので、どんなケースもペナルティは解消できる
- ビームサーチにしろ焼きなましにしろ、強い貪欲が必要
    - 一つのケースを手で解いてみよう
- 運ぶ経路を決める必要がある
    - マルチエージェントな感じはAHC008（動物を囲む回）に似ている
    - 経路の決定はAHC013（サーバールームの回）に似ている
        - 少し場合分けが必要そう
- クレーン0は自由に移動できる
- なんもわからん
    - 自由における場合を考える？
- トポロジカルソート
- いっぺんに解くのは難しそう
    - 自由度高すぎる
- 仮保持しなければおけないコンテナの個数を最小化
- 同時に動かすのは流石に難しい？
- 右から左に持っていくことはあまりしなさそう
- 退避したものを別の場所に移動させることはあるか？
    - 上げるのと下げるのにコストがかかるので、できれば避けたい
    - 横にシフトをする、とかの操作はありうる？
- クレーンの操作はタスク単位で良い？
    - 次のタスクを選ぶ、タスクが終わるまで時間を進める

- 行動単位を「コンテナcをマス(i,j)に運ぶ」とする
- 管理対象
    - コンテナを運ぶ順番
        - 並列で動かすので、順番が前後しそう
    - コンテナを仮に置く位置
    - コンテナを運ぶ経路
- 上記を決めれば、最適なクレーンの割り当てが決まる？
    - 多段階？
    - クレーンの割り当ては多いので、その場で適当にやって良さそう
    - 経路と一緒に最適化することになりそう

## 方針

- コンテナを一時保管する場所を固定する
- 全てのクレーンを使って一つずつ完成させる
    - 運べるものは運んでおく

# 5/18

- クレーン0だけを使えばペナルティはでないので、結局操作回数の最小化
    - 参加の敷居を下げるためだと予想
- コンテナを運ぶ順番を決めるのが良さそう
- 全部を一気にやるのは大変だが、方針は間違えないようにしたい
- クレーンは入り口->仮置き場、仮置き場->出口で役割を分けると無駄が減りそう
    - クレーン0はどっち？
        - 直感的には搬出をやった方が良さそう
- ボトルネックになるのは何か？
    - 運ぶ距離
    - クレーンの待ち時間
        - ガントチャートみたいなものを書く？
- 自由度
    - コンテナを運ぶ順番
    - コンテナを仮位置
- 運び出す順番が後なら、荷物を置く場所は後ろで良い
- 初手がわからん
- 各ジョブを貪欲にやった場合、どれくらい良い解が出るのか
- クレーンが1個の場合
- 仮置き場が自由な場合
- そんなに複雑なことをしたくない
- ターンの最小化 <-> クレーン0以外の待機時間を無くす

## 最適化対象

- 搬入順序
- 仮置き場所
- 搬出順序

- 上記が決まれば、クレーンは貪欲に割り当てれば良さそう
    - クレーンの割り当ては影響少なそう

## 搬入順序

- 仮置き状態のコンテナの個数を減らしたい
- 各時刻tに放置しているコンテナの個数の最小化
- 搬出できるコンテナは全て解消する

## 仮置き場所

- 搬出がしやすい配置を求めたい
- 各時刻の到達不可能なコンテナ配置の最小化

## 搬出順序

- 搬入がしやすくなるように、搬出順序に優先度をつけたい
- 搬出順序は貪欲に決まりそう？
    - 搬出できる状態になったらすぐに搬出した方が良い

## 解表現

- 搬入順序と仮置き場所

# 5/19

- 搬入順序と搬入場所は同時に最適化できそう
- 評価関数
    - 移動距離の総和
        - 搬入口からの距離と搬出口までの距離
    - 到達不可能なコンテナの個数
        - 搬入口から
            - 搬入するたびに到達可能か判定
        - 搬出口から
            - 搬出できるようになった時に到達可能か判定
    - 設置位置の衝突
- 並列なので、順番が前後しても頑健であってほしい
- クレーン0だけを使った解法を提出
    - 順位表を見ると絶対スコアは1/6倍程度にする必要がある
    - 60~70ターンくらいが目標、高々100ターンくらい
    - ビーム撃つことになりそう

## どうやってクレーンを複数動かすか

- ジョブを割り当てる
    - 行動は以下の3種類だが
        - 搬入する
        - 搬出する
        - 搬入と搬出をする
    - 全て、以下の一連の流れ
        - 拾いに行く
        - 拾う
        - 運ぶ
        - 降ろす
    - 最大ターン数が短いので、行動は1ターンずつで良さそう
    - 最適かというと、、
- 考えること
    - 衝突しないようにするには
    - 回避不可能な場合は？

- 最初は貪欲で良い

```rust
struct Task {
    from: (usize, usize),
    to: (usize, usize),
}
```

1. 新たに発生したタスクを列挙する
2. タスクがないクレーンにタスクを割り当てる
3. 各クレーンについて、以下の操作を順に行う
    1. 目的地にいれば、拾う・降ろす操作を行う
    2. いなければ、目的地に近づくような操作のうち、実行可能な操作を列挙する
        - 実行可能 := 次のターンにクレーンが存在しないマス、クレーンと交差しないマス
    3. 2.で列挙した操作からランダムに一つ選択し、実行する
        - 選べない場合はその場に留まる
4. 1.に戻る

- スタック対策
    - 片方が譲る
- 同時に同じ搬出口に運ぶには？
- 時刻t+dに通れなくなっていたら？
- ちゃんと最適化するには、各時刻の状態を記録する必要があるか
    - スタック対策にもなる

```rust
/// terminal[t][i][j] := 時刻tのマス(i, j)の状態
terminal: Vec<Vec<Vec<TileStatus>>>;

fn get_move_for_task(
    terminal: &Vec<Vec<Vec<TileStatus>>>,
    t: usize,
    from: (usize, usize),
    to: (usize, usize),
    task: Task,
) -> Vec<Move> {
    let mut dp = vec![vec![vec![false; N]; N]; T];
}
```

### 考察

- クレーンで持った状態になると、仮置きする必要はなくなる
- 待機が勿体無いので
    - 搬入口は同時に複数利用したい
    - なるべく最後は複数の搬出口に搬出していたい
    - 順序の評価関数を変えればどうにかなるか？
- おそらく方針では差がつかず、各要素の最適化精度で決まる問題な気がする
- 一個前の搬出が完了する時刻が判明したら、次の搬出もキューに入れたい

- 経路やクレーンの衝突を無視して（緩めて）最適化？
- クレーンの経路をどれくらい後から求められるか
- 中継地点の固定は強すぎる気がする
- スコアは1/7程度にする必要がありそう
    - 大体65ターンくらい？

- 貪欲で良さそう
- 経路は破壊再構築で作れそう

# 5/20

## 貪欲

```rust
struct Job {
    from: (usize, usize),
    to: (usize, usize),
}
```

- 実行するジョブを列挙する
- クレーンへのジョブの割り当てを貪欲に割り当てる
- ジョブを達成するクレーンの経路を求める

- ジョブの列挙

# 5/21

- 経路の探索
    - `O(T * N * N^2) = 100*125 = 12,500`

- 無理だった場合は？
    - first-stageに戻り、割り当てをやり直す
    - scheduleをt時刻分遅延させる
    - コンテナを置く位置を変える
    - タスクの割り当てを変更する
        - きついタスクをクレーン0に割り当てる

```rust
struct Job {
    c: (usize, usize)
    from: (usize, usize),
    to: (usize, usize),
};
```

```
1. jobs: Vec<(c: usize, from: (usize, usize), to: (usize, usize))>;
2. (
    crane_schedules: Vec<Vec<(t: usize, p: (usize, usize), is_pickup: bool)>>,
    container_occupations: Vec<Vec<Vec<Option<usize>>>>
);
3. (
    crane_log: Vec<Vec<Option<(usize, usize)>>>,
)
```

## 最適化

- 最適化方法
    - 局所探索（山登り）
- 評価関数（最小化）
    - 総ターン数 + ペナルティ
- 制約
    - 同時刻に複数のコンテナが同じ位置に存在しない
    - クレーン同士が衝突しない
    - 搬入、搬出順序が正しい
- 近傍
    - 経路の再探索
        - 変更するクレーンとスケジュールをランダムに選ぶ
        - 該当するスケジュールの経路をdpにより再探索する
        - スケジュールの所要時間が更新された場合
            - 以降のcrane_logをずらし、validでないクレーンの経路を再探索する
            - container_occupationsもずれるので、他のクレーンと衝突しないかも調べる必要がある
        - スケジュールの所要時間が更新されない場合（しない場合）
            - 何もしない
        - 見つからなければ巻き戻す
    - 配置を変更する
        - 配置を変更するコンテナcをランダムに選ぶ
        - container_positions, container_occupationsを更新する
        - crane_schedulesを更新する
            -   ```rust
                let (ci, t) = container_assigned[c];
                crane_schedules[ci][t].p = new_p;
                ```
        - t-1とtの経路を合わせて再探索する
            - 所要時間の更新有無は選べる・更新する場合は所定の処理をする
    - クレーン間のジョブの移動
        - 移動
            - 移動するクレーンと移動するジョブtを選ぶ（is_pickup = true）を選ぶ
            - 移動後のクレーンのランダムな箇所にジョブを挿入する
            - 移動前t-1->t+2の経路を再探索する
                - 再探索後には他のクレーンとの衝突状況を確認する
            - 挿入時刻をt'として、t'-1->t', t'->t'+1, t'+1->t'+2の経路を再探索する
                - 再探索後には他のクレーンとの衝突状況を確認する
        - スワップ
    - 順序のスワップ
- 初期解
    - クレーン0に全てアサインする
    - 貪欲にジョブを割り当てる
        - 配置はランダム

## 状態

```rust
struct State {
    // [最適化対象] 各クレーンが各時刻にどこにいるか
    crane_log: Vec<Option<p: (usize, usize)>>,
    // crane_schedules: Vec<Vec<(c: usize, start_t: usize, end_t: usize, start_p: (usize, usize), end_p: (usize, usize))>>,
    // crane_schedules: Vec<Vec<(t: usize, p: (usize, usize), c: usize, job_i: usize)>>,
    // is_pickup == (i % 2 == 0)
    crane_schedules: Vec<Vec<(t: usize, p: (usize, usize), c: usize, is_pickup: bool, job_i: usize)>>,
    container_occupations: Vec<Vec<Vec<Option<c: usize>>>>,
    container_positions: Vec<Vec<(start_t: usize, end_t: usize, p: (usize, usize))>>,
    container_assigned: Vec<Vec<(ci: usize, t: usize)>>,
}

impl State {
    fn can_move(self, ci: usize, t: usize, from: (usize, usize), to: (usize, usize));
    fn find_new_path(self, ci: usize, start_t: usize, end_t: usize, from: (usize, usize), to: (usize, usize));
    fn update_crane_path(self, ci: usize, start_t: usize, path: Vec<(usize, usize)>);
}
```

## 改善案

- ジョブを移動させるときに順序を守る
- 初期解を作る
- ぺナルティ項を足す
- 同じコンテナをn度運ぶ
- 複数クレーンを使って入り口で上手いこと搬入する

# 5/22

- やっぱり2段階で解こう
    - 差分更新は相当難しい
    - うまくいかなければ
        - 配置を変える
        - ジョブの入れ替え
        - ジョブの時間を伸ばす

```rust
/// コンテナを運ぶスケジュールを最適化する
/// Return:
/// crane_schedules: Vec<Vec<(t: usize, p: (usize, usize), is_pickup: bool)>>;
/// - クレーンがどの位置にいる必要があるかの制約
/// container_occupations: Vec<Vec<Vec<Option<usize>>>>;
/// - 各時刻の各マスのコンテナの設置状況
fn optimize_first_stage();

/// Return:
/// crane_moves: Vec<Vec<Move>>
/// - クレーンがとる行動
fn optimize_second_stage();
```

